#+TITLE: Dual Task Data Analysis
#+STARTUP: fold
#+PROPERTY: header-args:ipython :results both :exports both :async yes :session dual_data :kernel dual_data

* A few imports
#+begin_src ipython
  %load_ext autoreload
  %autoreload 2
  %reload_ext autoreload
#+end_src

#+RESULTS:
: The autoreload extension is already loaded. To reload it, use:
:   %reload_ext autoreload

# Out[1]:

#+begin_src ipython
  import os
  import sys

  sys.path.insert(0, '../dual_task')
  current_dir = os.path.dirname(os.path.abspath('__file__'))
  # Get parent directory (= the project root)
  project_root = os.path.join(current_dir, '..')
  # Append to system path
  sys.path.append(project_root)

  print("Python exe")
  print(sys.executable)

#+end_src

#+RESULTS:
: Python exe
: /home/leon/mambaforge/envs/dual_data/bin/python

#+begin_src ipython
    import numpy as np
    import matplotlib
    import matplotlib.pyplot as plt
    import seaborn as sns
    import pandas as pd

    sns.set_context("poster")
    sns.set_style("ticks")
    plt.rc("axes.spines", top=False, right=False)
    fig_path = '../figs/perf'
    golden_ratio = (5**.5 - 1) / 2
    width = 6

    matplotlib.rcParams['figure.figsize'] = [width, width * golden_ratio ]
    matplotlib.rcParams['lines.markersize'] = 5
    %matplotlib inline
    %config InlineBackend.figure_format = 'png'
#+end_src

#+RESULTS:

#+begin_src ipython   print('a test figure')
  plt.figure()
  plt.plot([1,2,3,4], '-o')
  plt.xlabel('x')
  plt.show()
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/d7e2f6dd1a25cbf4008ae3e26fb8893aca58aef1.png]]

* Behavioral performance
*** Imports
#+begin_src ipython :

  from dual_data.performance.perf_tasks import run_perf_tasks
#+end_src

#+RESULTS:
:results:
# Out[4]:
:end:

*** single mouse
#+begin_src ipython :
  run_perf_tasks(mouse='JawsM15', perf_type='correct', reload=0)
#+end_src

#+RESULTS:
:results:
0 - a489fbcc-b9d3-422c-a02e-5453a8d98dd5
:end:

*** all mice

#+begin_src ipython :
  # mice = ['ChRM04','JawsM15', 'JawsM18', 'ACCM03', 'ACCM04', 'AP02', 'AP12']
  mice = ['ChRM04','JawsM15', 'JawsM18']
  for mouse in mice:
      run_perf_tasks(mouse=mouse, perf_type='correct', reload=0)
      plt.close('all')
#+end_src

#+RESULTS:
:results:
# Out[6]:
:end:

#+begin_src ipython :
  run_perf_tasks(mouse='all', perf_type='correct', reload=0)
#+end_src

#+RESULTS:
:results:
# Out[14]:
[[file:./obipy-resources/BRwTr7.png]]
:end:
*** summary
#+begin_src ipython :
  import pickle as pkl
  from dual_data.common.plot_utils import concat_fig
#+end_src

#+RESULTS:
:results:
# Out[4]:
:end:

#+begin_src ipython :
  mice = ['ChRM04','JawsM15', 'JawsM18', 'ACCM03', 'ACCM04', 'AP02', 'AP12']
  # mice = ['ChRM04','JawsM15', 'JawsM18']

  files = ['../figs/' + i + '_behavior_tasks_correct.pkl' for i in mice]
  print(files)

  figlist = [pkl.load(open(file, "rb")) for file in files]
  print(figlist)
  plt.close('all')

  golden_ratio = (5**.5 - 1) / 2
  width = 4.3
  height = width * golden_ratio * 1.4
  figsize = [width, height]
  matplotlib.rcParams['lines.markersize'] = 5.5

  concat_fig('summary', figlist, dim=[3, 3], size=figsize, VLINE=0, LABEL=1, LABEL_POS=[-0.4, 1.2])

#+end_src

#+RESULTS:
:results:
# Out[19]:
[[file:./obipy-resources/f3MjRR.png]]
:end:

* Licktime analysis
*** Imports
#+begin_src ipython :results raw drawer :exports both
  from scipy.io import loadmat
  from dual_data.licks.licks import *
#+end_src

#+RESULTS:
:results:
# Out[20]:
:end:

*** Data
#+begin_src ipython :results output
  # path = '../data/behavior/DualTask_DPA_vs_Single_DPA/'
  path = '../data/behavior/DualTask-Silencing-ACC-Prl/'
  # path = '../data/behavior/DualTask-Silencing-Prl-ACC/'
  # path = '../data/behavior/DualTask-Silencing-ACC/'
#+end_src

#+RESULTS:

*** Single mouse
#+begin_src ipython :results raw drawer :exports both
  i_mouse = 2
  i_session = 1

  if 'DPA' in path:
      session = 'Dual' # control opto DPA or Dual
  else:
      session = 'control' # control opto DPA or Dual

  data = loadmat(path + session + '_mouse_%d/session_%d' % (i_mouse, i_session))
#+end_src

#+begin_src ipython :results raw drawer :exports both
  licks_dpa, licks_go, licks_nogo = get_licks_mouse(data, path, response='correct', trial_length=20, verbose=1)
  licks_all = [np.hstack(licks_dpa), np.hstack(licks_go), np.hstack(licks_nogo)]
  licks_density, bins = plot_licks_hist(licks_all, n_bins='auto')
#+end_src

#+RESULTS:
:results:
# Out[31]:
[[file:./obipy-resources/Hutbpp.png]]
:end:

*** All mice
#+begin_src ipython :results raw drawer :exports both
mice_dpa, mice_go, mice_nogo = get_licks_mice(path, n_session=11, response="incorrect")
#+end_src

#+RESULTS:
:results:
# Out[40]:
:end:

**** control
#+begin_src ipython :results raw drawer :exports both
  n_mice = 9
  dpa_all = hstack_with_padding(mice_dpa[:n_mice])
  go_all = hstack_with_padding(mice_go[:n_mice])
  nogo_all = hstack_with_padding(mice_nogo[:n_mice])

  licks_all = [ np.hstack(dpa_all), np.hstack(go_all), np.hstack(nogo_all)]
  licks_density, bins = plot_licks_hist(licks_all, n_bins='auto', n_mice=n_mice)
#+end_src

#+RESULTS:
:results:
# Out[41]:
[[file:./obipy-resources/9UfRSc.png]]
:end:

**** opto
#+begin_src ipython :results raw drawer :exports both
  dpa_all = hstack_with_padding(mice_dpa[n_mice:])
  go_all = hstack_with_padding(mice_go[n_mice:])
  nogo_all = hstack_with_padding(mice_nogo[n_mice:])

  licks_all = [ np.hstack(dpa_all), np.hstack(go_all), np.hstack(nogo_all)]
  licks_density, bins = plot_licks_hist(licks_all, n_bins='auto', n_mice=n_mice)
#+end_src

#+RESULTS:
:results:
# Out[42]:
[[file:./obipy-resources/xbd4s3.png]]
:end:

* Temporal decoding
*** Imports
#+begin_src ipython : :kernel dual_data
  from dual_data.decode.mne_scores import run_mne_scores
  from dual_data.decode.mne_cross_temp import run_mne_cross_temp
#+end_src

#+RESULTS:
:results:
# Out[13]:
:end:

*** Sample classification
#+begin_src ipython :
  run_mne_scores(mouse='JawsM15', features='sample', task='DPA', day='first')
#+end_src

#+RESULTS:
:results:
0 - c6322f82-67cc-4b8f-8880-16322e1cf07b
:end:

#+begin_src ipython :
  run_mne_cross_temp(features='sample', task='DPA', day='first')
#+end_src

#+RESULTS:
:results:
# Out[34]:
[[file:./obipy-resources/RNBphi.png]]
:end:
*** Distractor classification
#+begin_src ipython :
  run_mne_scores(features='distractor', task='Dual', day='first')
  run_mne_scores(features='distractor', task='Dual', day='last')
#+end_src

#+RESULTS:
:results:
# Out[103]:
[[file:./obipy-resources/o1QDkg.png]]
:end:

#+begin_src ipython :
  run_mne_cross_temp(features='distractor', task='Dual', day='first')
#+end_src

#+RESULTS:
:results:
# Out[37]:
[[file:./obipy-resources/JZg9RA.png]]
:end:
*** Choice decoding
**** single mouse
#+begin_src ipython :
  mouse='ChRM04'
  run_mne_scores(mouse=mouse, features='choice', task='Dual', day='first', bootstrap=0, balance=1)
#+end_src

#+RESULTS:
:results:
# Out[63]:
[[file:./obipy-resources/sG8jy0.png]]
:end:

#+begin_src ipython :
  run_mne_scores(mouse=mouse, features='choice', task='Dual', day='last', laser=0, balance=1)
#+end_src

#+RESULTS:
:results:
# Out[64]:
[[file:./obipy-resources/BDTeB0.png]]
:end:

**** all mice
#+begin_src ipython :
  mice = ['ChRM04','JawsM15', 'JawsM18', 'ACCM03', 'ACCM04']
  tasks = ['DPA', 'DualGo', 'DualNoGo', 'Dual']
  for mouse in mice:
      for task in tasks:
          run_mne_scores(mouse=mouse, features='choice', task=task, day='first', bootstrap=1)
          run_mne_scores(mouse=mouse, features='choice', task=task, day='last', bootstrap=1)
          plt.close('all')
#+end_src

* Overlaps
*** Imports
#+begin_src ipython
  from dual_data.overlap.get_overlap import run_get_overlap
#+end_src

#+RESULTS:

*** Sample Overlap
**** Parameters
#+begin_src ipython
      mice = ['JawsM15']
      tasks = ['DPA', 'DualGo', 'DualNoGo']
      days = ['first', 'last']

      kwargs = dict()
      kwargs = {'prescreen': 0, 'pval':0.05, 'trials':'correct', 'balance':0
                , 'method':'bolasso', 'bolasso_pval':0.05,
                'bootstrap':True, 'preprocess':True,
                'scaler_BL':'robust', 'avg_noise':True,
                'unit_var_BL':False,
                'clf':'SVM', 'scaler': None, 'tol':0.001,
                'out_fold': 'stratified',
                }
#+end_src

#+RESULTS:

**** single mouse

#+begin_src ipython

  mouse = 'ACCM04'
  task= 'DualGo'
  features = 'distractor'

  kwargs['show_AB'] = False

  for day in ['first', 'last']:
      run_get_overlap(mouse=mouse, features=features, task=task, day=day, **kwargs)
      kwargs['reload'] = False
#+end_src

#+RESULTS:
:RESULTS:
#+begin_example
    reading raw data
    mouse ACCM04 n_days 6 day 1 type dF all data: X (160, 113, 84) y (9, 160)
    X (160, 113, 84) y (9, 160)
    mouse ACCM04 n_days 6 day 2 type dF all data: X (160, 113, 84) y (9, 160)
    X (160, 113, 84) y (9, 160)
    mouse ACCM04 n_days 6 day 3 type dF all data: X (160, 113, 84) y (9, 160)
    X (160, 113, 84) y (9, 160)
    mouse ACCM04 n_days 6 day 4 type dF all data: X (160, 113, 84) y (9, 160)
    X (160, 113, 84) y (9, 160)
    mouse ACCM04 n_days 6 day 5 type dF all data: X (160, 113, 84) y (9, 160)
    X (160, 113, 84) y (9, 160)
    mouse ACCM04 n_days 6 day 6 type dF all data: X (160, 113, 84) y (9, 160)
    X (160, 113, 84) y (9, 160)
    X_days (960, 113, 84) y_days (960, 6)
    ##########################################
    PREPROCESSING: SCALER robust AVG MEAN 0 AVG NOISE True UNIT VAR False
    ##########################################
    ##########################################
    MODEL: SCALER None IMBALANCE False PRESCREEN 0 PCA False METHOD bolasso FOLDS stratified CLF SVM
    ##########################################
    DATA: FEATURES distractor TASK Dual TRIALS correct DAYS first LASER 0
    ##########################################
    multiple days
    X_S1 (86, 113, 84) X_S2 (89, 113, 84)
    X_avg (175, 113)
    boots_coefs (1000, 113)
    p_val (113,)
    significant 105
    X_fs (175, 105)
    samples (175,) features (113,) non zero 105
    ##########################################
    DATA: FEATURES sample TASK DualGo TRIALS correct DAYS first LASER 0
    ##########################################
    multiple days
    X_S1 (41, 113, 84) X_S2 (45, 113, 84)
    X (86, 113, 84) y (86,)
  bootstrap: 100% 1000/1000 [00:02<00:00, 471.69it/s]
    Done
    loading files from /home/leon/dual_task/dual_data/data/ACCM04
    X_days (960, 113, 84) y_days (960, 6)
    ##########################################
    PREPROCESSING: SCALER robust AVG MEAN 0 AVG NOISE True UNIT VAR False
    ##########################################
    ##########################################
    MODEL: SCALER None IMBALANCE False PRESCREEN 0 PCA False METHOD bolasso FOLDS stratified CLF SVM
    ##########################################
    DATA: FEATURES distractor TASK Dual TRIALS correct DAYS last LASER 0
    ##########################################
    multiple days
    X_S1 (121, 113, 84) X_S2 (118, 113, 84)
    X_avg (239, 113)
    boots_coefs (1000, 113)
    p_val (113,)
    significant 108
    X_fs (239, 108)
    samples (239,) features (113,) non zero 108
    ##########################################
    DATA: FEATURES sample TASK DualGo TRIALS correct DAYS last LASER 0
    ##########################################
    multiple days
    X_S1 (62, 113, 84) X_S2 (59, 113, 84)
    X (121, 113, 84) y (121,)
  bootstrap: 100% 1000/1000 [00:02<00:00, 489.04it/s]
    Done
#+end_example
[[file:./.ob-jupyter/ff1550143a7b9b1223e1d5917acbfd7eadfd2ace.png]]
:END:


**** all mice
#+begin_src ipython :
  mice = ['ChRM04', 'JawsM15', 'JawsM18', 'ACCM03', 'ACCM04']
  tasks = ['DPA', 'DualGo', 'DualNoGo']

  for mouse in mice:
      for task in tasks:
          run_get_overlap(mouse=mouse, features='sample', task=task, day='first', method='bolasso')
          run_get_overlap(mouse=mouse, features='sample', task=task, day='last', method='bolasso')
          plt.close('all')
#+end_src

#+RESULTS:
:results:
# Out[53]:
:end:

**** summary

*** Distractor overlap
**** single mouse
#+begin_src ipython :
  mouse = 'ACCM03'
  run_get_overlap(mouse=mouse, features='distractor', task='DualGo', day='first', method='bolasso')
  run_get_overlap(mouse=mouse, features='distractor', task='DualGo', day='last', method='bolasso')
#+end_src

#+RESULTS:
:results:
# Out[22]:
[[file:./obipy-resources/Qjhkrl.png]]
:end:

**** all mice
#+begin_src ipython :
  mice = ['ChRM04','JawsM15', 'JawsM18', 'ACCM03', 'ACCM04']
  tasks = ['DPA', 'DualGo', 'DualNoGo']
  for mouse in mice:
      for task in tasks:
          run_get_overlap(mouse=mouse, features='distractor', task=task, day='first', method='bolasso')
          run_get_overlap(mouse=mouse, features='distractor', task=task, day='last', method='bolasso')
          plt.close('all')
#+end_src

#+RESULTS:
:results:
0 - 5b753b51-b6d1-4bfd-8b76-3911e0550c68
:end:

* Representational Dynamics
*** Imports
#+begin_src ipython :
  from dual_data.overlap.get_cos_day import run_get_cos_day
#+end_src

#+RESULTS:
:results:
# Out[9]:
:end:

*** single mouse
#+begin_src ipython :
  run_get_cos_day(mouse='JawsM15', method='bolasso')
#+end_src

#+RESULTS:
:results:
# Out[12]:
[[file:./obipy-resources/4jLAUr.png]]
:end:

* Bump attractor Dynamics
*** Method
Here, I get the unitary normal vectors of the sample and distractor subspaces, namely, s and d
Then, I define theta[i] = arctan2(d[i], s[i]) and rearrange the neurons given their preferred location.
*** Imports
#+begin_src ipython
  from scipy.stats import circmean, circstd
  from dual_data.overlap.get_cos import run_get_cos, plot_bump
  from dual_data.common.plot_utils import add_vlines
#+end_src

#+RESULTS:
*** Parameters
#+begin_src ipython
  mice = ['JawsM15']
  tasks = ['DPA', 'DualGo', 'DualNoGo']
  days = ['first', 'last']

  kwargs = dict()
  kwargs = {'prescreen': 0, 'pval':0.05, 'trials':'correct', 'balance':0
            , 'method':'bolasso', 'bolasso_pval':0.001,
            'bootstrap':True, 'preprocess':True,
            'scaler_BL':'robust', 'avg_noise':True,
            'unit_var_BL':False,
            'clf':'log_loss', 'scaler': None, 'tol':0.001,
            'out_fold': 'stratified',
            }
#+end_src

#+RESULTS:

*** Single mouse
#+begin_src ipython
  mouse = 'JawsM15'
  task= 'DPA'


  day = 'first'
  X_first, y_first = run_get_cos(mouse=mouse, day=day, task=task, **kwargs)

  day = 'last'
  X_last, y_last = run_get_cos(mouse=mouse, day=day, task=task, **kwargs)

#+end_src

#+RESULTS:
#+begin_example
  loading files from /home/leon/dual_task/dual_data/data/JawsM15
  X_days (1152, 693, 84) y_days (1152, 6)
  ##########################################
  PREPROCESSING: SCALER robust AVG MEAN 0 AVG NOISE True UNIT VAR False
  ##########################################
  ##########################################
  MODEL: SCALER None IMBALANCE False PRESCREEN 0 PCA False METHOD bolasso FOLDS stratified CLF log_loss
  ##########################################
  DATA: FEATURES distractor TASK Dual TRIALS correct DAYS first LASER 0
  ##########################################
  multiple days
  X_S1 (55, 693, 84) X_S2 (70, 693, 84)
  boots_coefs (1000, 693)
  p_val (693,)
  significant 598
  X_fs (125, 598)
  samples (125,) features (693,) non zero 598
  ##########################################
  DATA: FEATURES sample TASK Dual TRIALS correct DAYS first LASER 0
  ##########################################
  multiple days
  X_S1 (60, 693, 84) X_S2 (65, 693, 84)
  boots_coefs (1000, 693)
  p_val (693,)
  significant 629
  X_fs (125, 629)
  samples (125,) features (693,) non zero 629
  non zeros (693,)
  ##########################################
  DATA: FEATURES sample TASK DPA TRIALS correct DAYS first LASER 0
  ##########################################
  multiple days
  X_S1 (35, 693, 84) X_S2 (35, 693, 84)
  (693,) (70, 693, 84)
  (70, 693, 84)
  Done
  loading files from /home/leon/dual_task/dual_data/data/JawsM15
  X_days (1152, 693, 84) y_days (1152, 6)
  ##########################################
  PREPROCESSING: SCALER robust AVG MEAN 0 AVG NOISE True UNIT VAR False
  ##########################################
  ##########################################
  MODEL: SCALER None IMBALANCE False PRESCREEN 0 PCA False METHOD bolasso FOLDS stratified CLF log_loss
  ##########################################
  DATA: FEATURES distractor TASK Dual TRIALS correct DAYS last LASER 0
  ##########################################
  multiple days
  X_S1 (78, 693, 84) X_S2 (82, 693, 84)
  boots_coefs (1000, 693)
  p_val (693,)
  significant 616
  X_fs (160, 616)
  samples (160,) features (693,) non zero 616
  ##########################################
  DATA: FEATURES sample TASK Dual TRIALS correct DAYS last LASER 0
  ##########################################
  multiple days
  X_S1 (79, 693, 84) X_S2 (81, 693, 84)
  boots_coefs (1000, 693)
  p_val (693,)
  significant 649
  X_fs (160, 649)
  samples (160,) features (693,) non zero 649
  non zeros (693,)
  ##########################################
  DATA: FEATURES sample TASK DPA TRIALS correct DAYS last LASER 0
  ##########################################
  multiple days
  X_S1 (45, 693, 84) X_S2 (44, 693, 84)
  (693,) (89, 693, 84)
  (89, 693, 84)
  Done
#+end_example

#+begin_src ipython
  plot_bump(X_first, y_first, -1, 'all', 100)
  plot_bump(X_last, y_last, -1, 'all', 100)
#+end_src

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/b27073d8f187badc28a5085fa5b48737e3c52650.png]]
[[file:./.ob-jupyter/c87c57fd74fb0d7f0eb8c5dbcdd7701156e054cd.png]]
:END:

#+begin_src ipython :
  plot_bump(X_first, y_first, 1, 'all', 100)
  plot_bump(X_last, y_last, 1, 'all', 100)
#+end_src

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/49cf0f4bd7fd666ee75cdc98d7fb031e9b168b19.png]]
[[file:./.ob-jupyter/2f4adadc3e9508c4145282fe582abea953c0cb5f.png]]
:END:

**** decoder
#+begin_src ipython

  def decode_bump(signal, axis=-1, windowSize=100, SMOOTH=False):
      signal_copy = signal.copy()
      if axis != -1 and signal.ndim != 1:
          signal_copy = np.swapaxes(signal_copy, axis, -1)

      if SMOOTH:
          signal_copy = circcvl(signal_copy, windowSize=10, axis=-1)

      length = signal_copy.shape[-1]
      dPhi = np.pi / length

      dft = np.dot(signal_copy, np.exp(-2.0j * np.arange(length) * dPhi))

      if axis != -1 and signal.ndim != 1:
          dft = np.swapaxes(dft, axis, -1)

      m1 = 2.0 * np.absolute(dft) / length
      phi = np.arctan2(dft.imag, dft.real) % (2.0 * np.pi)

      return m1, phi


  def circcvl(signal, windowSize=10, axis=-1):
      signal_copy = signal.copy()

      if axis != -1 and signal.ndim != 1:
          signal_copy = np.swapaxes(signal_copy, axis, -1)

      ker = np.concatenate(
          (np.ones((windowSize,)), np.zeros((signal_copy.shape[-1] - windowSize,)))
          )

      smooth_signal = np.real(
          np.fft.ifft(
              np.fft.fft(signal_copy, axis=-1) * np.fft.fft(ker, axis=-1), axis=-1
          )
      ) * (1.0 / float(windowSize))

      if axis != -1 and signal.ndim != 1:
          smooth_signal = np.swapaxes(smooth_signal, axis, -1)

      return smooth_signal

#+end_src

#+RESULTS:

**** Do Wimmer analysis see melanie
for each single trial bumps: extract circmean and circstd at each time point and average over trials
std of the circmean -> precision
mean of circstd -> width of the bump at each trials how the bump broadens (Klaus)

#+begin_src ipython
  from scipy.stats import bootstrap
  def my_boots_ci(X, statfunc, n_samples=10000, method="BCa", alpha=0.05, axis=0):
        boots_samples = bootstrap(
              (X,),
              statistic=statfunc,
              n_resamples=n_samples,
              method=method,
              confidence_level=1.0 - alpha,
              vectorized = True,
              axis = axis,
        )

        # print(boots_samples)

        ci = np.array([boots_samples.confidence_interval.low, boots_samples.confidence_interval.high])
        mean_boots = np.mean(boots_samples.bootstrap_distribution, axis=-1)

        ci[0] = mean_boots - ci[0]
        ci[1] = ci[1] - mean_boots

        return ci

#+end_src

#+RESULTS:

**** phase
#+begin_src ipython
  amp, phase_first = decode_bump(X_first, axis=1, SMOOTH=True)
  amp, phase_last = decode_bump(X_last, axis=1, SMOOTH=True)
#+end_src

#+RESULTS:

**** std of circmean of X
#+begin_src ipython
  def circ_mean(X, y, axis=0):
     # X = X % (2 * np.pi)
     X_copy = X.copy()
     X_copy[y==1] = (X_copy[y==1] - np.pi)
     cm = circmean(X_copy, axis=axis) * 180 / np.pi
     # cm = circmean(X[y==1], axis=axis) * 180 / np.pi
     # cm1 = circmean(X[y==-1], axis=axis) * 180 / np.pi
     # cm = (cm+cm1)/2

     return cm

  time = np.linspace(0, 14, 84)

  mean_first = circ_mean(phase_first, y_first)
  plt.plot(time, mean_first, label='first')
  ci = my_boots_ci(phase_first[y_first==-1], circmean, axis=0) * 180 / np.pi
  plt.fill_between(time, mean_first-ci[0], mean_first+ci[1], alpha=0.25)

  mean_last = circ_mean(phase_last, y_last)
  plt.plot(time, mean_last, label='last')
  ci = my_boots_ci(phase_last[y_last==-1], circmean, axis=0) * 180 / np.pi
  plt.fill_between(time, mean_last-ci[0], mean_last+ci[1], alpha=0.25)

  plt.xlabel('Time (s)');
  plt.ylabel('$<\phi>_k$ (°)');
  plt.ylim([0, 90])
  plt.legend()
  add_vlines()
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/1c90ee90ad6eaff2986e6415a2728023c9dae619.png]]
**** mean of circstd of X
#+begin_src ipython
  def circ_std(X, y=None, axis=0, label=''):
      std = circstd(X[y==-1], axis=axis) * 180 / np.pi
      std1 = circstd(X[y==1], axis=axis) * 180 / np.pi
      std = (std+std1) / 2

      return std

  std_first = circ_std(phase_first, y_first, label='first')
  plt.plot(time, std_first, label='first')
  ci = my_boots_ci(phase_first[y_first==-1], circstd, axis=0) * 180 / np.pi
  plt.fill_between(time, std_first-ci[0], std_first+ci[1], alpha=0.25)
  time = np.linspace(0, 14, 84)

  std_last = circ_std(phase_last, y_last, label='last')
  plt.plot(time, std_last, label='first')
  ci = my_boots_ci(phase_last[y_last==-1], circstd, axis=0) * 180 / np.pi
  plt.fill_between(time, std_last-ci[0], std_last+ci[1], alpha=0.25)

  plt.xlabel('Time (s)');
  plt.ylabel('$<\delta \phi>_k$ (°)');
  plt.legend()
  add_vlines()
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/1a2a281abd90997d2d2fe18dedc65bbcc4dc451a.png]]

**** Drift
#+begin_src ipython
  time = np.linspace(0, 14, 84)
  sample_off = (time>= 3.) & (time<3.2)

  phase = phase_first[y_first==-1]
  drift = phase - phase[:, sample_off]

  phase = phase_first[y_first==1]
  drift1 = phase - phase[:, sample_off]

  drift = np.vstack((drift, drift1))

  plt.plot(time, np.mean(drift**2, 0))

  phase = phase_last[y_last==-1]
  drift = phase - phase[:, sample_off]

  phase = phase_last[y_last==1]
  drift1 = phase - phase[:, sample_off]

  drift = np.vstack((drift, drift1))

  plt.plot(time, np.mean(drift**2, 0))
  plt.xlabel('Time (s)')
  plt.ylabel('Accuracy ($deg^2$)')
  add_vlines()
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/718734a7ff2f3d1e41b2eff15cf704d3fd2e9e2b.png]]

**** Diffusion
#+begin_src ipython

  phase = phase_first[y_first==-1]
  # dtheta = phase - np.mean(phase, axis=0)
  dtheta = phase - circmean(phase, axis=0)

  phase = phase_first[y_first==1]
  # dtheta1 = phase - np.mean(phase, axis=0)
  dtheta1 = phase - circmean(phase, axis=0)

  dtheta = np.vstack((dtheta, dtheta1))

  plt.plot(time, np.mean(dtheta**2, axis=0))

  phase = phase_last[y_last==-1]
  # dtheta = phase - np.mean(phase, axis=0)
  dtheta = phase - circmean(phase, axis=0)

  phase = phase_last[y_last==1]
  # dtheta1 = phase - np.mean(phase, axis=0)
  dtheta1 = phase - circmean(phase, axis=0)

  dtheta = np.vstack((dtheta, dtheta1))

  plt.plot(time, np.mean(dtheta**2, axis=0))

  plt.xlabel('Time (s)')
  plt.ylabel('Precision ($deg^2$)')
  add_vlines()

#+end_src

#+RESULTS:
[[file:./.ob-jupyter/895ee0a7216ba699919c79513c8a64b5f1b9732d.png]]
